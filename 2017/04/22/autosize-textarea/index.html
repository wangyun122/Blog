<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> autosize--textarea · this.dog</title><meta name="description" content="autosize--textarea - wangyun"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://this.dog/atom.xml" title="this.dog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/wangyun122" target="_blank" class="nav-list-link">WEIBO</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">autosize--textarea</h1><div class="post-info">Apr 22, 2017</div><div class="post-content">  <script src="https://unpkg.com/vue/dist/vue.js"></script>
  <style>
    .wrapper {
      display: inline-block;
      width: 100%;
      position: relative;
      vertical-align: middle;
      margin: 0;
      padding: 0;
    }

    textarea {
      max-width: 100%;
      vertical-align: bottom;
      font-size: 14px;
    }

    .i-input {
      display: inline-block;
      width: 300px;
      line-height: 1.5;
      padding: 4px 7px;
      border: 1px solid #d7dde4;
      border-radius: 4px;
      color: #657180;
      background-color: #fff;
      background-image: none;
      position: relative;
      cursor: text;
    }

    .i-input:hover {
      border-color: #42b983;
    }

    .i-input:focus {
      border-color: #42b983;
      outline: 0;
    }
  </style>



  <div id="app">
    <div class="wrapper">
      <textarea class="i-input" ref="textarea" :style="textareaStyles" placeholder="请输入..." :value="currentValue" @input="handleInput">
        </textarea>
    </div>
  </div>

  <script>
    var hiddenTextarea;

    var HIDDEN_STYLE = `
    height:0 !important;
    min-height:0 !important;
    max-height:none !important;
    visibility:hidden !important;
    overflow:hidden !important;
    position:absolute !important;
    z-index:-1000 !important;
    top:0 !important;
    right:0 !important
`;

    var CONTEXT_STYLE = [
      'letter-spacing',
      'line-height',
      'padding-top',
      'padding-bottom',
      'font-family',
      'font-weight',
      'font-size',
      'text-rendering',
      'text-transform',
      'width',
      'text-indent',
      'padding-left',
      'padding-right',
      'border-width',
      'box-sizing'
    ];
    new Vue({
      el: '#app',
      data: {
        textareaStyles: {},
        currentValue: this.value,
        autosize: {
          type: [Object, Boolean],
          defaule: true
        }
      },
      mounted:function(){
        this.resizeTextarea();
      },
      methods: {
        handleInput: function(event) {
          var value = event.target.value;
          if (this.number) value = Number.isNaN(Number(value)) ? value : Number(value);
          this.setCurrentValue(value);
        },
        setCurrentValue: function(value) {
          if (value === this.currentValue) return;
          this.$nextTick(() => {
            this.resizeTextarea();
          });
          this.currentValue = value;
        },
        resizeTextarea() {
          const autosize = this.autosize;

          const minRows = autosize.minRows;
          const maxRows = autosize.maxRows;

          this.textareaStyles = this.calcTextareaHeight(this.$refs.textarea, minRows, maxRows);
        },
        calcTextareaHeight(targetNode, minRows = null, maxRows = null) {
          if (!hiddenTextarea) {
            hiddenTextarea = document.createElement('textarea');
            document.body.appendChild(hiddenTextarea);
          }

          let {
            paddingSize,
            borderSize,
            boxSizing,
            contextStyle
          } = this.calculateNodeStyling(targetNode);

          hiddenTextarea.setAttribute('style', `${contextStyle};${HIDDEN_STYLE}`);
          hiddenTextarea.value = targetNode.value || targetNode.placeholder || '';

          let height = hiddenTextarea.scrollHeight;
          let minHeight = -Infinity;
          let maxHeight = Infinity;

          if (boxSizing === 'border-box') {
            height = height + borderSize;
          } else if (boxSizing === 'content-box') {
            height = height - paddingSize;
          }

          hiddenTextarea.value = '';
          let singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;

          if (minRows !== null) {
            minHeight = singleRowHeight * minRows;
            if (boxSizing === 'border-box') {
              minHeight = minHeight + paddingSize + borderSize;
            }
            height = Math.max(minHeight, height);
          }
          if (maxRows !== null) {
            maxHeight = singleRowHeight * maxRows;
            if (boxSizing === 'border-box') {
              maxHeight = maxHeight + paddingSize + borderSize;
            }
            height = Math.min(maxHeight, height);
          }

          return {
            height: `${height}px`,
            minHeight: `${minHeight}px`,
            maxHeight: `${maxHeight}px`
          };
        },
        calculateNodeStyling: function(node) {
          const style = window.getComputedStyle(node);

          const boxSizing = style.getPropertyValue('box-sizing');

          const paddingSize = (
            parseFloat(style.getPropertyValue('padding-bottom')) +
            parseFloat(style.getPropertyValue('padding-top'))
          );

          const borderSize = (
            parseFloat(style.getPropertyValue('border-bottom-width')) +
            parseFloat(style.getPropertyValue('border-top-width'))
          );

          const contextStyle = CONTEXT_STYLE
            .map(name => `${name}:${style.getPropertyValue(name)}`)
            .join(';');

          return {
            contextStyle,
            paddingSize,
            borderSize,
            boxSizing
          };
        }

      }
    })
  </script></div></article></div></main><footer><div class="paginator"><a href="/2017/04/17/lodash/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://this.dog">wangyun</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>